---
title: 'redux理解和集成'
date: 2017-05-25 13:59:38
category: 前端
tags: [React,redux]

---

React组件化的思想，使React本身仅仅是一个图形库的概念，这种抽离的思想，使React的移植和维护异常出众，令人诟病的性能问题，据说马上也会出现各种morden，提高性能。

redux的思想来源于flux而不同于flux，更简洁，更精化。思想本身其实很容易理解，无非就是store（只有一个）对整体的state进行存储，通过reducer对state进行控制（这里要注意一下，一般情况下，返回的state需要新对象，不适合在原有的state进行更改），发起执行的命令是action，网上有很多类似的图片流程。

button=》（通过button回调函数）dispatch=》（通过dispatch（action））reduce=》（通过改变state）view

## redux的重要原则

* 单一数据源：也就是说在redux应用中最终生成的状态树只有一颗，根节点只有一个，但是可以有不同的跟节点，也就是状态中的每一个部分都可以单独进行维护和处理。最后利用Redux提供的工具函数combineReducers进行总生成即可。
* 状态只读：store中的状态是只读的，不能直接进行修改，其实在Redux中，store并不需要自己专门去维护，他的生成主要靠的是reducer，只要我们将reducer安排好，最终利用creatStore即可生成store。
* 状态的修改是纯函数：reducer本身是一个纯函数，增强了状态的可预测性。

## 一个redux的基本demo（同步Action）

模拟三个按键，每个按键代表一种状态，且同时只能激活一个。

### 定义基本组件（单个按键）

link.js

```js
import React from 'react';
import PropTypes from 'prop-types';

const Link=({active,children,onClick})=>{
    if(active){
        return <span>{children}</span>
    }
    return(
    <a href="#" onClick={e=>{
        e.preventDefault();
        onClick()
    }}>
    {children}</a>
    )
}
Link.propTypes = {
  active : PropTypes.bool.isRequired,
  children: PropTypes.node.isRequired,
  onClick : PropTypes.func.isRequired
}

export default Link;

```
这是一个无状态组件，本身的状态和state无关，从而便于解耦移植。

### 容器型组件

既然生成的是一个无状态组件，是一个展示型组件，此时就需要一个容器型组件对组件的内容进行控制。这个容器型组件是作为组件与redux进行沟通的桥梁。

LinkContainer.js

```js
import {connect} from 'react-redux';
import {setVisibilityFilter} from '../actions'
import Link from '../component/Link';

const mapToState=(state,mprops)=>({
    active:mprops.filter===state.visibilityFilter
})
const mapToDispatch=(dispatch,mprops)=>({
    onClick:() => {
    dispatch(setVisibilityFilter(mprops.filter))
  }
})

// const mapToDispatch={
//  onClick: setVisibilityFilter("SHOW_ACTIVE")
// }
const LinkContainer=connect(mapToState,mapToDispatch)(Link);
export default LinkContainer;

```

其中connect是react-redux的工具方法，对组件进行一个包装，其中的```mapToState```和```mapToDispatch```分别描述的是store状态树对应的参数和组件的dispatch对应的参数。connect本身还可以另外接收两个函数一个参数类型是```mergeProp(mapToState,mapToDispatch,ownprops)```前两个参数分别是connect前两个参数函数的返回值，ownprops是当前组件的参数。最终返回完整的props。还可以接受一个对象，其中包含两个值pure=true（添加shouldComponentUpdate()，并进行浅层对比优化）和withRef=false（为true时，为组件添加ref值，使用getWrappedInstance()获取ref）。

### actions

在上一节中，对于onClick方法指向的是一个dispacth（action）的响应:

actions.js

```js
export const setVisibilityFilter = (filter) => ({
  type: 'SET_VISIBILITY_FILTER',
  filter
})

```
其中的type代表不同类型的action从而便于在reducer中进行分类处理，并且这是一个标准规范，必须要有。那我们的dispatch（action）之后，到哪里进行处理呢，当然是reducer啦

### reducers

```js
import { combineReducers } from 'redux'
const visibilityFilter=(state= "SHOW_ALL",action)=>{
  switch (action.type) {
    case 'SET_VISIBILITY_FILTER':
        return action.filter;
      
    default:
      // statements_def
        return state;
  }
}
const todos = (state = [], action) => {
  ...
}


const todoApp = combineReducers({
  todos,visibilityFilter
})

export default todoApp;

```

其中combineReducers是一个工具函数，用于将所有的reducers最后合并成一个reducer，因为store只有一个的原则。

到这里，我们看到了消息发送的过程，看到了action被dispatch的过程，看到了reducer处理action并修改state的过程，然而，我们的组件本身是怎么监听这个state的呢？

### store与组件的连接

```js
import React from 'react'
import { render } from 'react-dom'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import LinkContainer from './container/LinkContainer'
import todos from './reduces'

const store = createStore(todos)

render(
  <Provider store={store}>
   <p>
    <LinkContainer filter="SHOW_ALL">SHOW ALL</LinkContainer>
    <LinkContainer filter="SHOW_ACTIVE">SHOW ACTIVE</LinkContainer>
    <LinkContainer filter="SHOW_COMPLETED">SHWO COMPLETED</LinkContainer>
    </p>
  </Provider>,
  document.getElementById('root')
)

```
利用react-redux提供的Provider，将redux的状态树与组件进行连接。创建store利用reducer进行生成。到此一个demo的闭环形成。

## MiddlerWare机制
middleware的目的就是能够使dispatch多样性处理，也就是action在到达reducer之前进行拦截处理。例如我们想在每次dispacth前后打印log，这个时候middleware就比自己进行hack合理友好。
模拟功能函数：
```js
function logger(store) {
  return function wrapDispatchToAddLogging(next) {
    return function dispatchAndLog(action) {
      console.log('dispatching', action)
      let result = next(action)
      console.log('next state', store.getState())
      return result
    }
  }
}

//这里可以改成箭头函数形式的curry函数
const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}


function applyMiddleware(store, middlewares) {
  middlewares = middlewares.slice()
  middlewares.reverse()

  let dispatch = store.dispatch
  middlewares.forEach(middleware =>
    dispatch = middleware(store)(dispatch)
  )

  return Object.assign({}, store, { dispatch })
}

```
[实现参考中文文档](http://cn.redux.js.org/docs/advanced/Middleware.html)

### Redux中的middleware源码分析

Reduxmiddleware源码：
```js
import compose from './compose'
export default function applyMiddleware(...middlewares){
  //应用时applyMiddlerware（m1,m2,m3）(creatStore)(reducer,null),next指代的就是creatStore
    return (next) => (reducer,initialState) => {
      let store=next(reducer,initialState);
      let dispatch=store.dispatch;
      let chain=[];
      var middlerwareAPI={
        getState:store.getState,
        dispatch:(action)=>dispatch(action),
      }
      chain=middlewares.map(middleware=>middleware(middlerwareAPI));
      dispatch=compose(...chain)(store.dispatch);

      return{
        ...store,
        dispatch,
      };
    }
}

```
在middlerwareAPI中dispatch的赋值使用的是匿名函数，保证在applyMiddlerware之后能够得到最新的dispatch。
其中compose的实现在Redux中是从右往左，```compose(f1,f2,f3)(store.dispatch)```效果如```dispatch=f1(f2(f3(store.dispatch)))```

